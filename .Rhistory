probs = c(0.50, 0.90, 0.99))
quantile_table_2D(cases_tp_children, chosen = c("cases_tp_children", "Pill_tp_children", "dose"),
probs = c(0.50, 0.90, 0.99))
quantile_table_2D(cases_hpp_children, chosen = c("cases_hpp_children", "Pill_hpp_children", "dose"),
probs = c(0.50, 0.90, 0.99))
quantile_table_2D(cases_pef_children, chosen = c("cases_pef_children", "Pill_pef_children", "dose"),
probs = c(0.50, 0.90, 0.99))
#| eval: false
#| echo: false
quantile_table_2D(cases_tp_adults, chosen = c("cases_tp_adults", "Pill_tp_adults", "consumer_dose_tp"),
probs = c(0.50, 0.90, 0.99))
quantile_table_2D(cases_hpp_adults, chosen = c("cases_hpp_adults", "Pill_hpp_adults", "consumer_dose_hpp"),
probs = c(0.50, 0.90, 0.99))
quantile_table_2D(cases_pef_adults, chosen = c("cases_pef_adults", "Pill_pef_adults", "consumer_dose_pef"),
probs = c(0.50, 0.90, 0.99))
quantile_table_2D(cases_tp_children, chosen = c("cases_tp_children", "Pill_tp_children", "consumer_dose_tp"),
probs = c(0.50, 0.90, 0.99))
quantile_table_2D(cases_hpp_children, chosen = c("cases_hpp_children", "Pill_hpp_children", "consumer_dose_hpp"),
probs = c(0.50, 0.90, 0.99))
quantile_table_2D(cases_pef_children, chosen = c("cases_pef_children", "Pill_pef_children", "consumer_dose_pef"),
probs = c(0.50, 0.90, 0.99))
#| eval: true
cases_tp_adults$density_plot()
cases_tp_adults$density_plot_2D()
cases_hpp_adults$density_plot()
cases_hpp_adults$density_plot_2D()
cases_pef_adults$density_plot()
cases_pef_adults$density_plot_2D()
cases_tp_adults$cummulative_plot()
cases_tp_adults$cummulative_plot_2D()
cases_hpp_adults$cummulative_plot()
cases_hpp_adults$cummulative_plot_2D()
cases_pef_adults$cummulative_plot()
cases_pef_adults$cummulative_plot_2D()
#| eval: true
cases_tp_children$density_plot()
cases_tp_children$density_plot_2D()
cases_hpp_children$density_plot()
cases_hpp_children$density_plot_2D()
cases_pef_children$density_plot()
cases_pef_children$density_plot_2D()
cases_tp_children$cummulative_plot()
cases_tp_children$cummulative_plot_2D()
cases_hpp_children$cummulative_plot()
cases_hpp_children$cummulative_plot_2D()
cases_pef_children$cummulative_plot()
cases_pef_children$cummulative_plot_2D()
# t_hpp <- Constant$new("t_hpp", 5) # the treatment time (minutes)
inactivation_hpp <- LogLinInactivation$new("Treatment_hpp")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", sec_model_hpp)$
map_input("t", Constant$new("t_hpp", 1))
#| eval: true
#| echo: false
#| include: false
# We first load our libraries
library(tidyverse)
library(biorisk)
#|eval: true
logN0 <- Uniform$new("logN0", # A uniform distribution
level = 0)$
map_input("min",
Constant$new("logN0_min", 0) # with a constant min. value
)$
map_input ("max",
Constant$new("logN0_max", 1) # and a constant max. value
)
#|eval: false
# The equivalent scenario without variability
logN0 <- 0.5
logDref <- -0.67
t_value <- 1.97
sigma <- 0.62
logDrefupper <- logDref + t_value*sigma
logDreflower <- logDref - t_value*sigma
# Convert from log scale to the original scale
Drefupper <- 10^logDrefupper
Dreflower <- 10^logDreflower
# Print the result
print(Drefupper)
print(Dreflower)
## Secondary model
#temperature <- Normal$new("temperature", level = 0)$  # Normal pressure level with some variability assigned
#map_input("mu", Constant$new("temperature_mu", 72))$
# map_input("sigma", Constant$new("temperature_sigma", 5))
Dref_tp <- Constant$new("Dref_tp", Drefupper)
sec_model_tp <- Dz_model$new("D_tp")$
map_input("Dref", Dref_tp)$
map_input("temperature", Constant$new("temperature", 72))$
map_input("z", Constant$new("z_tp", 10.67))$
map_input("Tref", Constant$new("Tref", 70))
t_tp <- Constant$new("t_tp", 0.333) # the treatment time (minutes)
inactivation_tp <- LogLinInactivation$new("Treatment_tp")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", sec_model_tp)$
map_input("t", t_tp)
# t_hpp <- Constant$new("t_hpp", 5) # the treatment time (minutes)
inactivation_hpp <- LogLinInactivation$new("Treatment_hpp")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", sec_model_hpp)$
map_input("t", Constant$new("t_hpp", 1))
#| eval: true
#| echo: false
#| include: false
# We first load our libraries
library(tidyverse)
library(biorisk)
#|eval: true
logN0 <- Uniform$new("logN0", # A uniform distribution
level = 0)$
map_input("min",
Constant$new("logN0_min", 0) # with a constant min. value
)$
map_input ("max",
Constant$new("logN0_max", 1) # and a constant max. value
)
#|eval: false
# The equivalent scenario without variability
logN0 <- 0.5
logDref <- -0.67
t_value <- 1.97
sigma <- 0.62
logDrefupper <- logDref + t_value*sigma
logDreflower <- logDref - t_value*sigma
# Convert from log scale to the original scale
Drefupper <- 10^logDrefupper
Dreflower <- 10^logDreflower
# Print the result
print(Drefupper)
print(Dreflower)
## Secondary model
#temperature <- Normal$new("temperature", level = 0)$  # Normal pressure level with some variability assigned
#map_input("mu", Constant$new("temperature_mu", 72))$
# map_input("sigma", Constant$new("temperature_sigma", 5))
Dref_tp <- Constant$new("Dref_tp", Drefupper)
sec_model_tp <- Dz_model$new("D_tp")$
map_input("Dref", Dref_tp)$
map_input("temperature", Constant$new("temperature", 72))$
map_input("z", Constant$new("z_tp", 10.67))$
map_input("Tref", Constant$new("Tref", 70))
t_tp <- Constant$new("t_tp", 0.333) # the treatment time (minutes)
inactivation_tp <- LogLinInactivation$new("Treatment_tp")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", sec_model_tp)$
map_input("t", t_tp)
#|eval: true
logN0 <- Uniform$new("logN0", # A uniform distribution
level = 0)$
map_input("min",
Constant$new("logN0_min", 0) # with a constant min. value
)$
map_input ("max",
Constant$new("logN0_max", 1) # and a constant max. value
)
t_tp <- Constant$new("t_tp", 0.333) # the treatment time (minutes)
inactivation_tp <- LogLinInactivation$new("Treatment_tp")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", sec_model_tp)$
map_input("t", t_tp)
# t_hpp <- Constant$new("t_hpp", 5) # the treatment time (minutes)
inactivation_hpp <- LogLinInactivation$new("Treatment_hpp")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", sec_model_hpp)$
map_input("t", Constant$new("t_hpp", 1))
#| eval: false
#| echo: false
# The equivalent without variability and using the Dref
logDref <- -0.67
Dref <- 10^logDref
print(Dref)
#| eval: false
#| echo: false
plot_model(inactivation_tp)
#| eval: true
#| echo: true
# The equivalent scenario without variability
logN0 <- Constant$new("logN0", 0.5)
#| eval: true
#| echo: true
# The equivalent without variability and using the Dref
logDref <- -0.67
Dref <- 10^logDref
print(Dref)
#| eval: true
#| echo: true
# The equivalent without variability and uncertainty
# Secondary model
Dref_tp <- Constant$new("Dref_tp", Dref)
sec_model_tp <- Dz_model$new("D_tp")$
map_input("Dref", Dref_tp)$
map_input("temperature", Constant$new("temperature", 72))$
map_input("z", Constant$new("z_tp", 10.67))$
map_input("Tref", Constant$new("Tref", 70))
t_tp <- Constant$new("t_tp", 0.333) # the treatment time (minutes)
inactivation_tp <- LogLinInactivation$new("Treatment_tp")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", sec_model_tp)$
map_input("t", t_tp)
#| eval: true
#| echo: true
# The equivalent without variability
# Secondary model
pressure <- Constant$new("pressure_mu", 550)
# Dref_hpp <- Uniform$new("Dref_hpp", level = 0)$  # Variability in Dref
# map_input("min", Constant$new("Dref_hpp_min", 1))$
# map_input("max", Constant$new("Dref_hpp_max", 4))
sec_model_hpp <- Dz_model$new("D_hpp")$
map_input("Dref", Constant$new("Dref_hpp", 1.3))$
map_input("temperature", pressure)$
map_input("z", Constant$new("z_hpp", 304))$
map_input("Tref", Constant$new("Pref", 400))
# t_hpp <- Constant$new("t_hpp", 5) # the treatment time (minutes)
inactivation_hpp <- LogLinInactivation$new("Treatment_hpp")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", sec_model_hpp)$
map_input("t", Constant$new("t_hpp", 1))
#| eval: true
#| echo: true
# The equivalent without variability
energy_pef <- Constant$new("energy_mu", 120)
inactivation_pef <- LogLinInactivation$new("Treatment_pef")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", Constant$new("D_pef", 82.5))$
map_input("t", energy_pef)
#| eval: false
#| echo: false
plot_model(inactivation_tp)
#| eval: false
#| echo: false
plot_model(inactivation_hpp)
#| eval: false
#| echo: false
plot_model(inactivation_pef)
inactivation_tp$simulate(1000)
inactivation_tp$density_plot()
inactivation_pef$simulate(1000)
inactivation_pef$density_plot()
inactivation_hpp$simulate(1000)
inactivation_hpp$density_plot()
#| eval: true
#| echo: true
#The equivalent without variability
# Define the serving_size object
serving_size <- Constant$new("max_size", 200)  # Map the 'max' input to a constant value of 200
# Define a function to create a Concentration2Dose object with mapped inputs
# This function takes two arguments: 'name' and 'logN_input'
# @param name The name of the Concentration2Dose object
# @param logN_input The input object to map to the 'logN' parameter
# @return A Concentration2Dose object with the specified mappings
create_consumer_dose <- function(name, logN_input) {
Concentration2Dose$new(name)$  # Create a new Concentration2Dose object with the given name
map_input("logN", logN_input)$  # Map the 'logN' input to the provided 'logN_input' argument
map_input("size", serving_size)  # Map the 'size' input to the 'serving_size' object
}
# Use the function to create three different consumer dose objects
# Create 'consumer_dose_tp' by calling the function with 'dose' name and 'growth_distrib_tp' for logN
consumer_dose_tp <- create_consumer_dose("dose", inactivation_tp)
# Create 'consumer_dose_hpp' by calling the function with 'dose' name and 'growth_distrib_hpp' for logN
consumer_dose_hpp <- create_consumer_dose("dose", inactivation_hpp)
# Create 'consumer_dose_pef' by calling the function with 'dose' name and 'growth_distrib_pef' for logN
consumer_dose_pef <- create_consumer_dose("dose", inactivation_pef)
# Define a function to create a Concentration2Dose object with mapped inputs
# This function takes two arguments: 'name' and 'logN_input'
# @param name The name of the Concentration2Dose object
# @param logN_input The input object to map to the 'logN' parameter
# @return A Concentration2Dose object with the specified mappings
create_consumer_dose <- function(name, logN_input) {
Concentration2Dose$new(name)$  # Create a new Concentration2Dose object with the given name
map_input("logN", logN_input)$  # Map the 'logN' input to the provided 'logN_input' argument
map_input("size", serving_size)  # Map the 'size' input to the 'serving_size' object
}
# Use the function to create three different consumer dose objects
# Create 'consumer_dose_tp' by calling the function with 'dose' name and 'growth_distrib_tp' for logN
consumer_dose_tp <- create_consumer_dose("consumer_dose_tp", inactivation_tp)
# Create 'consumer_dose_hpp' by calling the function with 'dose' name and 'growth_distrib_hpp' for logN
consumer_dose_hpp <- create_consumer_dose("consumer_dose_hpp", inactivation_hpp)
# Create 'consumer_dose_pef' by calling the function with 'dose' name and 'growth_distrib_pef' for logN
consumer_dose_pef <- create_consumer_dose("consumer_dose_pef", inactivation_pef)
# Define a function to create a DoseResponse_Exponential object with mapped inputs
# This function takes two arguments: 'name' and 'dose_input'
# @param name The name of the DoseResponse_Exponential object
# @param dose_input The input object to map to the 'dose' parameter
# @return A DoseResponse_Exponential object with the specified mappings
create_pill <- function(name, dose_input, r_value) {
DoseResponse_Exponential$new(name)$  # Create a new DoseResponse_Exponential object with the given name
map_input("r", Constant$new("r_dr", r_value))$  # Map the 'r' input to the given r value
map_input("dose", dose_input)  # Map the 'dose' input to the provided 'dose_input' argument
}
# Create the Pill objects for children and adults separately
Pill_tp_adults <- create_pill("Pill_tp_adults", consumer_dose_tp, 5.1e-3)
Pill_hpp_adults <- create_pill("Pill_hpp_adults", consumer_dose_hpp, 5.1e-3)
Pill_pef_adults <- create_pill("Pill_pef_adults", consumer_dose_pef, 5.1e-3)
Pill_pef_children <- create_pill("Pill_pef_children", consumer_dose_pef, 9.3e-3)
Pill_tp_children <- create_pill("Pill_tp_children", consumer_dose_tp, 9.3e-3)
Pill_hpp_children <- create_pill("Pill_hpp_children", consumer_dose_hpp, 9.3e-3)
# Calculate the median values for each dose response object for both children and adults
pill_median_tp_adults <- Pill_tp_adults$point_estimate()
pill_median_hpp_adults <- Pill_hpp_adults$point_estimate()
pill_median_pef_adults <- Pill_pef_adults$point_estimate()
pill_median_tp_children <- Pill_tp_children$point_estimate()
pill_median_hpp_children <- Pill_hpp_children$point_estimate()
pill_median_pef_children <- Pill_pef_children$point_estimate()
print(pill_median_tp_adults)
print(pill_median_hpp_adults)
print(pill_median_pef_adults)
print(pill_median_tp_children)
print(pill_median_hpp_children)
print(pill_median_pef_children)
#| eval: true
servings_adults <- 0.8*4.6e10
servings_children <- 0.2*4.6e10
# Calculate the mean cases values by multiplying each combined median value by 4.6e10
cases_mean_tp <- (pill_median_tp_children * servings_children) + (pill_median_tp_adults * servings_adults)
cases_mean_hpp <- (pill_median_hpp_children * servings_children) + (pill_median_hpp_adults * servings_adults)
cases_mean_pef <- (pill_median_pef_children * servings_children) + (pill_median_pef_adults * servings_adults)
# Print the cases_mean values
print(cases_mean_tp)
print(cases_mean_hpp)
print(cases_mean_pef)
#| eval: true
# Define a function to create a Pill2Cases_N object with mapped inputs
# This function takes two arguments: 'name' and 'pill_input'
# @param name The name of the Pill2Cases_N object
# @param pill_input The input object to map to the 'Pill' parameter
# @param servings_input The input object to map to the 'Pill' parameter
# @return A Pill2Cases_N object with the specified mappings
create_cases <- function(name, pill_input, servings_input) {
Pill2Cases_N$new(name)$  # Create a new Pill2Cases_N object with the given name
map_input("Pill", pill_input)$  # Map the 'Pill' input to the provided 'pill_input' argument
map_input("servings", Constant$new("n_servings", servings_input))  # Map the 'servings' input to the corresponding value for adults and children
}
# Create the cases objects for each combined median value
cases_tp_adults <- create_cases("cases_tp_adults", Pill_tp_adults,
servings_adults)
cases_hpp_adults <- create_cases("cases_hpp_adults", Pill_hpp_adults, servings_adults)
cases_pef_adults <- create_cases("cases_pef_adults", Pill_pef_adults, servings_adults)
cases_tp_children <- create_cases("cases_tp_children", Pill_tp_children, servings_children)
cases_hpp_children <- create_cases("cases_hpp_children", Pill_hpp_children, servings_children)
cases_pef_children <- create_cases("cases_pef_children", Pill_pef_children, servings_children)
# Calculate and print the number of cases for each Pill object
cases_tp_adults_value <- cases_tp_adults$point_estimate()
cases_hpp_adults_value <- cases_hpp_adults$point_estimate()
cases_pef__adults_value <- cases_pef_adults$point_estimate()
cases_tp_children_value <- cases_tp_children$point_estimate()
cases_hpp_children_value <- cases_hpp_children$point_estimate()
cases_pef_children_value <- cases_pef_children$point_estimate()
print(cases_tp_adults_value)
print(cases_hpp_adults_value)
print(cases_pef__adults_value)
print(cases_tp_children_value)
print(cases_hpp_children_value)
print(cases_pef_children_value)
#| eval: false
#| echo: false
plot_model(cases_tp_adults)
#| eval: true
#| echo: true
# The equivalent without variability and using the Dref
logDref <- -1.77 #this is the value from Esther for fruit juices and ciders without other additives (26 datapoints and extrapolation the equation is: y = -0.1785x + 10.723 R² = 0.9057)
Dref <- 10^logDref
print(Dref)
# Define a function to create a Concentration2Dose object with mapped inputs
# This function takes two arguments: 'name' and 'logN_input'
# @param name The name of the Concentration2Dose object
# @param logN_input The input object to map to the 'logN' parameter
# @return A Concentration2Dose object with the specified mappings
create_consumer_dose <- function(name, logN_input) {
Concentration2Dose$new(name)$  # Create a new Concentration2Dose object with the given name
map_input("logN", logN_input)$  # Map the 'logN' input to the provided 'logN_input' argument
map_input("size", serving_size)  # Map the 'size' input to the 'serving_size' object
}
# Use the function to create three different consumer dose objects
# Create 'consumer_dose_tp' by calling the function with 'dose' name and 'growth_distrib_tp' for logN
consumer_dose_tp <- create_consumer_dose("consumer_dose_tp", inactivation_tp)
# Create 'consumer_dose_hpp' by calling the function with 'dose' name and 'growth_distrib_hpp' for logN
consumer_dose_hpp <- create_consumer_dose("consumer_dose_hpp", inactivation_hpp)
# Create 'consumer_dose_pef' by calling the function with 'dose' name and 'growth_distrib_pef' for logN
consumer_dose_pef <- create_consumer_dose("consumer_dose_pef", inactivation_pef)
print(consumer_dose_tp)
# Define a function to create a Concentration2Dose object with mapped inputs
# This function takes two arguments: 'name' and 'logN_input'
# @param name The name of the Concentration2Dose object
# @param logN_input The input object to map to the 'logN' parameter
# @return A Concentration2Dose object with the specified mappings
create_consumer_dose <- function(name, logN_input) {
Concentration2Dose$new(name)$  # Create a new Concentration2Dose object with the given name
map_input("logN", logN_input)$  # Map the 'logN' input to the provided 'logN_input' argument
map_input("size", serving_size)  # Map the 'size' input to the 'serving_size' object
}
# Use the function to create three different consumer dose objects
# Create 'consumer_dose_tp' by calling the function with 'dose' name and 'growth_distrib_tp' for logN
consumer_dose_tp <- create_consumer_dose("consumer_dose_tp", inactivation_tp)
# Create 'consumer_dose_hpp' by calling the function with 'dose' name and 'growth_distrib_hpp' for logN
consumer_dose_hpp <- create_consumer_dose("consumer_dose_hpp", inactivation_hpp)
# Create 'consumer_dose_pef' by calling the function with 'dose' name and 'growth_distrib_pef' for logN
consumer_dose_pef <- create_consumer_dose("consumer_dose_pef", inactivation_pef)
consumer_dose_tp$point_estimate()
# Define a function to create a Concentration2Dose object with mapped inputs
# This function takes two arguments: 'name' and 'logN_input'
# @param name The name of the Concentration2Dose object
# @param logN_input The input object to map to the 'logN' parameter
# @return A Concentration2Dose object with the specified mappings
create_consumer_dose <- function(name, logN_input) {
Concentration2Dose$new(name)$  # Create a new Concentration2Dose object with the given name
map_input("logN", logN_input)$  # Map the 'logN' input to the provided 'logN_input' argument
map_input("size", serving_size)  # Map the 'size' input to the 'serving_size' object
}
# Use the function to create three different consumer dose objects
# Create 'consumer_dose_tp' by calling the function with 'dose' name and 'growth_distrib_tp' for logN
consumer_dose_tp <- create_consumer_dose("consumer_dose_tp", inactivation_tp)
# Create 'consumer_dose_hpp' by calling the function with 'dose' name and 'growth_distrib_hpp' for logN
consumer_dose_hpp <- create_consumer_dose("consumer_dose_hpp", inactivation_hpp)
# Create 'consumer_dose_pef' by calling the function with 'dose' name and 'growth_distrib_pef' for logN
consumer_dose_pef <- create_consumer_dose("consumer_dose_pef", inactivation_pef)
consumer_dose_tp$point_estimate()
consumer_dose_hpp$point_estimate()
consumer_dose_pef$point_estimate()
# Define a function to create a Concentration2Dose object with mapped inputs
# This function takes two arguments: 'name' and 'logN_input'
# @param name The name of the Concentration2Dose object
# @param logN_input The input object to map to the 'logN' parameter
# @return A Concentration2Dose object with the specified mappings
create_consumer_dose <- function(name, logN_input) {
Concentration2Dose$new(name)$  # Create a new Concentration2Dose object with the given name
map_input("logN", logN_input)$  # Map the 'logN' input to the provided 'logN_input' argument
map_input("size", serving_size)  # Map the 'size' input to the 'serving_size' object
}
# Use the function to create three different consumer dose objects
# Create 'consumer_dose_tp' by calling the function with 'dose' name and 'growth_distrib_tp' for logN
consumer_dose_tp <- create_consumer_dose("consumer_dose_tp", inactivation_tp)
# Create 'consumer_dose_hpp' by calling the function with 'dose' name and 'growth_distrib_hpp' for logN
consumer_dose_hpp <- create_consumer_dose("consumer_dose_hpp", inactivation_hpp)
# Create 'consumer_dose_pef' by calling the function with 'dose' name and 'growth_distrib_pef' for logN
consumer_dose_pef <- create_consumer_dose("consumer_dose_pef", inactivation_pef)
inactivation_tp$point_estimate()
inactivation_hpp$point_estimate()
inactivation_pef$point_estimate()
consumer_dose_tp$point_estimate()
consumer_dose_hpp$point_estimate()
consumer_dose_pef$point_estimate()
#| eval: true
#| echo: false
#| include: false
# We first load our libraries
library(tidyverse)
library(biorisk)
#| eval: true
#| echo: true
# The equivalent scenario without variability
logN0 <- Constant$new("logN0", 0)
#| eval: true
#| echo: true
# The equivalent without variability and using the Dref
logDref <- -1.77 #this is the value from Esther for fruit juices and ciders without other additives (26 datapoints and extrapolation the equation is: y = -0.1785x + 10.723 R² = 0.9057)
Dref <- 10^logDref
print(Dref)
#| eval: true
#| echo: true
# The equivalent without variability and uncertainty
# Secondary model
Dref_tp <- Constant$new("Dref_tp", Dref)
sec_model_tp <- Dz_model$new("D_tp")$
map_input("Dref", Dref_tp)$
map_input("temperature", Constant$new("temperature", 71.111))$
map_input("z", Constant$new("z_tp", 5.602))$ #this is the value from Esther for fruit juices and ciders without other additives
map_input("Tref", Constant$new("Tref", 70))
t_tp <- Constant$new("t_tp", 0.1) # the treatment time (minutes, 6 seconds)
inactivation_tp <- LogLinInactivation$new("Treatment_tp")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", sec_model_tp)$
map_input("t", t_tp)
#| eval: true
#| echo: true
# The equivalent without variability
# Secondary model
# Dref_hpp <- Uniform$new("Dref_hpp", level = 0)$  # Variability in Dref
# map_input("min", Constant$new("Dref_hpp_min", 1))$
# map_input("max", Constant$new("Dref_hpp_max", 4))
sec_model_hpp <- Dz_model$new("D_hpp")$
map_input("Dref", Constant$new("Dref_hpp", 1.13))$
map_input("temperature", Constant$new("pressure_mu", 550))$
map_input("z", Constant$new("z_hpp", 269.7))$
map_input("Tref", Constant$new("Pref", 400))
# t_hpp <- Constant$new("t_hpp", 5) # the treatment time (minutes)
inactivation_hpp <- LogLinInactivation$new("Treatment_hpp")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", sec_model_hpp)$
map_input("t", Constant$new("t_hpp", 1))
#| eval: true
#| echo: true
# The equivalent without variability
model_pef <- LogLinInactivation$new("Treatment_pef")$
map_input("logN0", Constant$new("intercept_pef", 0.72907))$ #We map logN0 to the intercept
map_input("D", Constant$new("D_pef", 40.37832)$
map_input("t", Constant$new("energy_pef", 120))
inactivation_pef <- LogLinInactivation$new("Treatment_pef")$
#| eval: false
#| echo: false
# D_pef <- Uniform$new("D_pef", level = 0)$  # Variability in D_pef
# map_input("min", Constant$new("D_pef_min", 60))$
# map_input("max", Constant$new("D_pef_max", 80))
energy_pef <- Normal$new("energy_pef", level = 0)$  # Normal energy input level with some variability assigned
map_input("mu", Constant$new("energy_mu", 120))$
map_input("sigma", Constant$new("energy_sigma", 2))
model_pef <- LogLinInactivation$new("Treatment_pef")$
map_input("logN0", Constant$new("intercept_pef", 0.72907))$ #We map logN0 to the intercept
map_input("D", Constant$new("D_pef", 40.37832))$
map_input("t", energy_pef)
inactivation_pef <- LogLinInactivation$new("Treatment_pef")$
map_input("logN0", logN0)$ #We map logN0 to the initial count defined before
map_input("D", model_pef)$
map_input("t", energy_pef)
